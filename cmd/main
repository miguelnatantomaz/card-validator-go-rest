package main

import (
	"encoding/csv"
	"net/http"
	"time"

	"fmt"

	"log"
	"os"

	"github.com/gin-gonic/gin"
	"github.com/gocolly/colly"
)


type Card struct {
	Number  string  `json:"Number"`
	Name    string  `json:"Name"`
	Type    string  `json:"Type"`
	Level   string  `json:"Level"`
	Country string  `json:"Country"`
}
func main2() {
  r := gin.Default()
  r.GET("/ping", func(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{
      "message": "pong",
    })
  })
	r.GET("/albums", getAlbums)
	r.POST("/albums", postAlbums)
	r.GET("/albums/:id", getAlbumById)
	r.GET("/scrape", func(c *gin.Context) {
		go CardScrapingFactory("http://binlist.io/country/brazil/page/", 66)
		c.JSON(http.StatusOK, gin.H{"message": "Scraping started"})
	})

  r.Run() // listen and serve on 0.0.0.0:8080 (for windows "localhost:8080")
}

type album struct {
	ID     string  `json:"id"`
	Title  string  `json:"title"`
	Artist string  `json:"artist"`
	Price  float64 `json:"price"`
}

var albums = []album{
	{ID: "1", Title: "Title 1", Artist: "Artist 1", Price: 234},
	{ID: "2", Title: "Title 2", Artist: "Artist 2", Price: 65},
	{ID: "3", Title: "Title 3", Artist: "Artist 3", Price: 23},
	{ID: "4", Title: "Title 4", Artist: "Artist 4", Price: 999},
}

func getAlbums(c *gin.Context) {
	c.IndentedJSON(http.StatusOK, albums)
}

func getAlbumById(c *gin.Context) {
	id := c.Param("id")

	for _, a := range albums {
		if a.ID == id {
			c.IndentedJSON(http.StatusOK, a)
			return
		}
	}
	c.IndentedJSON(http.StatusNotFound, gin.H{ "message": "Album not found" })
}

func postAlbums(c *gin.Context) {
	var newAlbum album
	 
	if err := c.Bind(&newAlbum); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
    return
	}

	albums = append(albums, newAlbum)
	c.IndentedJSON(http.StatusCreated, newAlbum)
}

func CardScrapingFactory(url string, page_size int) {
	var cards []Card

	fmt.Println("AAAAAA")
	c := colly.NewCollector(
		colly.Async(true),
	)

	c.Limit(&colly.LimitRule{
		Delay: 2 * time.Second,
		RandomDelay:  1 * time.Second,
	})

	// called before an HTTP request is triggered
	c.OnRequest(func(r *colly.Request) {
		r.Headers.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64)")
	})

	// triggered when the scraper encounters an error
	c.OnError(func(_ *colly.Response, err error) {
			fmt.Println("Something went wrong: ", err)
	})

	// fired when the server responds
	c.OnResponse(func(r *colly.Response) {
			fmt.Println("Page visited: ", r.Request.URL)
	})

	// triggered when a CSS selector matches an element
	c.OnHTML("tbody", func(e *colly.HTMLElement) {
		e.ForEach("tr", func(_ int, el *colly.HTMLElement) {
			card := Card{
				Number: el.ChildText("td:nth-child(1)"),
				Name: el.ChildText("td:nth-child(2)"),
				Type: el.ChildText("td:nth-child(3)"),
				Level: el.ChildText("td:nth-child(4)"),
				Country:el.ChildText("td:nth-child(5)"),
			}

			cards = append(cards, card)
		})
	})

	// triggered once scraping is done (e.g., write the data to a CSV file)
	c.OnScraped(func(r *colly.Response) {
			fmt.Println(r.Request.URL, " scraped!")
			file, err := os.Create("cards.csv")
			if err != nil {
					log.Fatalln("Failed to create output CSV file", err)
			}
			defer file.Close()

			writer := csv.NewWriter(file)
			headers := []string{
					"Number",
					"Name",
					"Type",
					"Level",
					"Country",
			}
			writer.Write(headers)

        // write each product as a CSV row
        for _, card := range cards {
            // convert a Product to an array of strings
            record := []string{
                card.Name,
                card.Number,
                card.Type,
                card.Level,
                card.Country,
            }

            // add a CSV record to the output file
            writer.Write(record)
        }
        defer writer.Flush()
	})

	for i := 1; i <= page_size; i++ {
		concat_url := fmt.Sprintf("%s%d%s", url, i, "/")
		fmt.Println("Iteração:", concat_url)

		err := c.Visit(concat_url)
		if err != nil {
				fmt.Println("Erro ao visitar a página:", err)
		}
	}


	c.Wait()
}